/* 
 * pragma-logger
 *
 * Copyright (c) 2013 Pragma Dudes and project contributors.
 *
 * pragma-logger's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, 
 * publish, distribute, sublicense, and/or sell copies of the Software, 
 * and to permit persons to whom the Software is furnished to do so, 
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 * This license applies to all parts of pragma-logger that are not externally
 * maintained libraries.
 */

'use strict';

var path = require('path'),
	fs = require('fs');

module.exports = PragmaLogger;

/**
 * Create new instance of neutrino PragmaLogger.
 * @param {Object} config neutrino config object.
 * @param {string} name of current logger instance.
 * @constructor
 *
 */
function PragmaLogger(config, name) {
	if (!config) {
		throw new Error('Config object is undefined!');
	}

	this._config = config;
	this._messageFormat =
		this._config.logger.messageFormat || this._messageFormat;
	this._name = name || this._name;

	this.debug = this.debug.bind(this);
	this.error = this.error.bind(this);
	this.warn = this.warn.bind(this);
	this.trace = this.trace.bind(this);
	this.info = this.info.bind(this);
}

/**
 * Current config object.
 * @type {Object}
 */
PragmaLogger.prototype._config = null;

/**
 * Name of current logger instance.
 * @type {string}
 */
PragmaLogger.prototype._name = 'defaultLogger';

/**
 * Output message format.
 * @type {string}
 *
 * Format:
 * %name - name of current logger instance
 * %t - current Date
 * %lvl - message level
 * %pid - process id
 * %msg - message
 */
PragmaLogger.prototype._messageFormat =
	'%t \t| %name :: %lvl \t| PID: %pid - %msg';

/**
 * Write error message.
 * @param {Error} error Error object.
 */
PragmaLogger.prototype.error = function (error) {
	this.write('error', error);
};

/**
 * Write debug message
 * @param {string} message Message.
 */
PragmaLogger.prototype.debug = function (message) {
	this.write('debug', message);
};

/**
 * Write warning message
 * @param {string} message Message.
 */
PragmaLogger.prototype.warn = function (message) {
	this.write('warn', message);
};

/**
 * Write trace message
 * @param {string} message Message.
 */
PragmaLogger.prototype.trace = function (message) {
	this.write('trace', message);
};

/**
 * Write info message
 * @param {string} message Message.
 */
PragmaLogger.prototype.info = function (message) {
	this.write('info', message);
};

/**
 * Write log message to console and file.
 * @param {string} level Type of message which specify log file path.
 * @param {string|Error} message Log message.
 */
PragmaLogger.prototype.write = function (level, message) {

	if (!this._config.logger || !this._config.logger.levels ||
		!(level in this._config.logger.levels)) {
		return;
	}

	var now = new Date(),
		charset = this._config.logger.charset,
		nowUtc = now.toUTCString(),

		logFilePath = this._config.logger.levels[level]
			.replace('%pid', process.pid)
			.replace('%y', now.getUTCFullYear())
			.replace('%m', now.getUTCMonth() + 1)
			.replace('%d', now.getUTCDate())
			.replace('%h', now.getUTCHours()),
		logFolderPath = path.dirname(logFilePath),
		toConsole = this._messageFormat
			.replace('%name', this._name)
			.replace('%t', nowUtc)
			.replace('%lvl', level)
			.replace('%pid', process.pid)
			.replace('%msg',
				message instanceof Error ? message.stack : message);

	if (level === 'error') {
		console.error(toConsole);
	} else {
		console.log(toConsole);
	}

	fs.exists(logFolderPath, function (exists) {

		if (!exists) {
			return;
		}

		var fileConfig = {flags: 'a', encoding: charset},
			logFile = fs.createWriteStream(path.resolve(logFilePath),
				fileConfig);

		logFile.end(toConsole + '\n');

	});
};